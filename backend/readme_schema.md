# Schema

The application data is store in three relational tables in PostgreSQL.

## Table Of Content <!-- omit from toc -->

- [Schema](#schema)
  - [Tables](#tables)
    - [Users](#users)
    - [Robots](#robots)
    - [Readings](#readings)

## Tables

### Users

1. Columns
   - `id`: A unique identifier autogenerated by postgres. This is the primary key.
   - `auth_id`: a varchar(36) used to store the Auth0 Id from Auth0. Cannot be null and has a unique index.
   - `name`: a varchar(36) used to store the name of the user.
   - `email`: a varchar(48) used to store the email of the user. Has to be a valid email, cannot be null, and has a unique index.
   - `api_key`: a varchar(36) autogenerated using a random function. It is used to verify that a robot belongs to a specific user when posting readings. Cannot be null and has a unique index.
   - `preferences`: a JSON column used to store schemaless data about the user (mostly data used in the UI such as theme preference, language settings etc.).
   - `status`: a varchar(16) used to store the status of the user (active or deleted). It uses an Enum that the api converts to a string.  
2. Indexes
   - on `id` as primary key
   - on `auth_id` as unique index
   - on `email` as unique index
   - on `api_key` as unique index
   - on `status` as lookup index
3. Foreign Keys
   - None
4. Other constraints
   - `email` validity is enforced at the ORM level by listening to the event `set` on the comumn `email` using this regular expression: `[^@]+@[^@]+\.[^@]+`

### Robots

1. Columns
   - `id`: A unique identifier autogenerated by postgres. This is the primary key.
   - `user_id`: a unique identifier used to store the id from the user's table. Cannot be null and has a unique index. It's the foreign key for the users-->robots one to many ralationship.
   - `name`: a varchar(36) used to store the name of the user.
   - `description`: a varchar() used to store a description of the robot. Can be null.
   - `mac`: a varchar(36) used to store the robot unique MAC address. Must be a valid MAC address, cannot be null and has a unique index.
   - `preferences`: a JSON column used to store schemaless data about the robot configuration and settings (mostly data used to configure the arduino based robot like onboard sensors, collection frequency, roaming distance, roaming speed, etc.). Since different robot have different sensors and configuration needs, storing as schemaless json provides more flexibility than using a relational model.
   - `status`: a varchar(16) used to store the status of the user (active or deleted). It uses an Enum that the api converts to a string.  
2. Indexes
    - on `id` as primary key
    - on `mac` as unique index
    - on `status` as lookup index
3. Foreign Keys
   - on `user_id` as one to many (one usert -> many robots)
4. Other constraints
   - `MAC` validity is enforced at the ORM level by listening to the event `set` on the comumn `mac` using this regular expression: `(([0-9A-Fa-f]{2}[-:]){5}[0-9A-Fa-f]{2})|(([0-9A-Fa-f]{4}\.){2}[0-9A-Fa-f]{4})`  

### Readings

1. Columns
   - `id`: A unique identifier autogenerated by postgres. This is the primary key.
   - `robot_id`: a unique identifier used to store the id from the robot's table. Cannot be null and has a unique index. It's the foreign key for the robots-->reading one to many relationship.
   - `data`: a JSON column used to store schemaless data about the sensor readings. Sensors such as battery, pressure, humidity etc. mostly report values as string:double tuples. Since different robot have different sensors and configuration needs, using schemaless json to store the array of tuples provides more flexibility than using a relational model.
   - `date`: a datetime field with timezone used to store the date and time a reading was recorded by a robot. Cannot be null, has index.
2. Indexes
   - on `id` as primary key
   - on `date` as lookup index
3. Foreign Keys
   - on `robot_id` as one to many (one robot -> many readings)
4. Other constraints
   - None
